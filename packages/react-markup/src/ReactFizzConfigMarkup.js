/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import {
  pushStartInstance as pushStartInstanceImpl,
  writePreambleStart as writePreambleStartImpl,
} from "react-dom-bindings/src/server/ReactFizzConfigDOM";

import { NotPending } from "react-dom-bindings/src/shared/ReactDOMFormActions";

import hasOwnProperty from "shared/hasOwnProperty";

// Allow embedding inside another Fizz render.
export const isPrimaryRenderer = false;

// Disable Client Hooks
export const supportsClientAPIs = false;

import { stringToChunk } from "react-server/src/ReactServerStreamConfig";

export {
  canHavePreamble,
  completeResumableState,
  createHoistableState,
  createPreambleState,
  createRenderState,
  createResumableState,
  createRootFormatContext,
  doctypeChunk,
  emitEarlyPreloads,
  getChildFormatContext,
  getSuspenseContentFormatContext,
  getSuspenseFallbackFormatContext,
  hoistHoistables,
  hoistPreambleState,
  isPreambleContext,
  isPreambleReady,
  makeId,
  pushEndInstance,
  pushFormStateMarkerIsMatching,
  pushFormStateMarkerIsNotMatching,
  resetResumableState,
  writeClientRenderBoundaryInstruction,
  writeCompletedBoundaryInstruction,
  writeCompletedSegmentInstruction,
  writeEndPendingSuspenseBoundary,
  writeEndSegment,
  writeHoistables,
  writeHoistablesForBoundary,
  writePlaceholder,
  writePostamble,
  writePreambleEnd,
  writeStartPendingSuspenseBoundary,
  writeStartSegment,
} from "react-dom-bindings/src/server/ReactFizzConfigDOM";

import escapeTextForBrowser from "react-dom-bindings/src/server/escapeTextForBrowser";

export function getViewTransitionFormatContext(
  resumableState,
  parentContext,
  update,
  enter,
  exit,
  share,
  name,
  autoName, // name or an autogenerated unique name
) {
  // ViewTransition reveals are not supported in markup renders.
  return parentContext;
}

export function pushStartInstance(
  target,
  type,
  props,
  resumableState,
  renderState,
  preambleState,
  hoistableState,
  formatContext,
  textEmbedded,
) {
  for (const propKey in props) {
    if (hasOwnProperty.call(props, propKey)) {
      const propValue = props[propKey];
      if (propKey === "ref" && propValue != null) {
        throw new Error(
          "Cannot pass ref in renderToHTML because they will never be hydrated.",
        );
      }
      if (typeof propValue === "function") {
        throw new Error(
          "Cannot pass event handlers (" +
            propKey +
            ") in renderToHTML because " +
            "the HTML will never be hydrated so they can never get called.",
        );
      }
    }
  }

  return pushStartInstanceImpl(
    target,
    type,
    props,
    resumableState,
    renderState,
    preambleState,
    hoistableState,
    formatContext,
    textEmbedded,
  );
}

export function pushTextInstance(
  target,
  text,
  renderState,
  textEmbedded,
) {
  // Markup doesn't need any termination.
  target.push(stringToChunk(escapeTextForBrowser(text)));
  return false;
}

export function pushSegmentFinale(
  target,
  renderState,
  lastPushedText,
  textEmbedded,
) {
  // Markup doesn't need any termination.
  return;
}

export function pushStartActivityBoundary(
  target,
  renderState,
) {
  // Markup doesn't have any instructions.
  return;
}

export function pushEndActivityBoundary(
  target,
  renderState,
) {
  // Markup doesn't have any instructions.
  return;
}

export function writeStartCompletedSuspenseBoundary(
  destination,
  renderState,
) {
  // Markup doesn't have any instructions.
  return true;
}

export function writeStartClientRenderedSuspenseBoundary(
  destination,
  renderState,
  // flushing these error arguments are not currently supported in this legacy streaming format.
  errorDigest,
  errorMessage,
  errorStack,
  errorComponentStack,
) {
  // Markup doesn't have any instructions.
  return true;
}

export function writeEndCompletedSuspenseBoundary(
  destination,
  renderState,
) {
  // Markup doesn't have any instructions.
  return true;
}
export function writeEndClientRenderedSuspenseBoundary(
  destination,
  renderState,
) {
  // Markup doesn't have any instructions.
  return true;
}

export function writePreambleStart(
  destination,
  resumableState,
  renderState,
  skipBlockingShell,
) {
  return writePreambleStartImpl(
    destination,
    resumableState,
    renderState,
    true, // skipBlockingShell
  );
}

export function writeCompletedRoot(
  destination,
  resumableState,
  renderState,
  isComplete,
) {
  // Markup doesn't have any bootstrap scripts nor shell completions.
  return true;
}

export function hasSuspenseyContent(hoistableState) {
  // Never outline.
  return false;
}

export const NotPendingTransition = NotPending;
